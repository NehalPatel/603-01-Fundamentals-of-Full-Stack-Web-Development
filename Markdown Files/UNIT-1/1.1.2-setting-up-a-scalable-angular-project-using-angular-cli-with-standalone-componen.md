unit: 1
topic: Setting up a scalable Angular project using Angular CLI with Standalone Components
objectives: ["Understand the core ideas of Setting up a scalable Angular project using Angular CLI with Standalone Components","Implement a working example related to Setting up a scalable Angular project using Angular CLI with Standalone Components","Apply best practices and avoid common mistakes in Setting up a scalable Angular project using Angular CLI with Standalone Components","Use Angular 17 patterns effectively"]
difficulty: Advanced
---

# Scalable Project Setup with Angular CLI (Standalone)

## Learning Objectives

- Create a production-ready Angular 17 project
- Use standalone architecture and application configuration
- Organize a scalable folder structure and lazy routes
- Configure linting, environments, and testing

## Overview

- Angular CLI scaffolds projects that default to standalone components
- Vite dev server and esbuild builder provide fast builds and HMR
- Application configuration is centralized in `main.ts` or `app.config.ts`

## Project Creation

```bash
ng new shop-app --routing --style=scss
cd shop-app
ng serve
```

## Application Configuration

```ts
// app/app.config.ts
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient } from '@angular/common/http';
import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes), provideHttpClient()]
};
```

```ts
// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { appConfig } from './app/app.config';

bootstrapApplication(AppComponent, appConfig);
```

## Folder Structure

```text
src/
  app/
    core/
      services/
      guards/
    shared/
      ui/
      pipes/
    features/
      products/
      cart/
    app.component.ts
    app.routes.ts
  assets/
  environments/
```

## Lazy Loading (Standalone)

```ts
// app/app.routes.ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  { path: '', loadComponent: () => import('./features/home/home.component').then(m => m.HomeComponent) },
  { path: 'products', loadComponent: () => import('./features/products/products.component').then(m => m.ProductsComponent) }
];
```

## Environments and Linting

```bash
ng g environments
ng add @angular-eslint/schematics
```

## Practical Exercises

### Exercise

- Create `features/products` with a standalone component and lazy route
- Add a `ProductService` in `core/services` and inject it into the component

### Solution

```bash
ng g component app/features/products --standalone
ng g service app/core/services/product
```

```ts
// app/core/services/product.service.ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class ProductService {
  list(){ return [{ id: 1, name: 'Laptop' }]; }
}
```

```ts
// app/features/products/products.component.ts
import { Component, inject } from '@angular/core';
import { ProductService } from '../../core/services/product.service';

@Component({
  selector: 'app-products',
  standalone: true,
  template: `
    <h2>Products</h2>
    @for(p of products; track p.id){
      <p>{{ p.name }}</p>
    }
  `
})
export class ProductsComponent {
  products = inject(ProductService).list();
}
```

## Diagram

```mermaid
flowchart LR
  M[main.ts] --> AC[app.config.ts]
  AC --> R[provideRouter]
  R --> Routes
  Routes --> F[Feature Components]
```

## Troubleshooting & Pitfalls

- Keep `core` and `shared` free of feature-specific dependencies
- Use `loadComponent` for standalone lazy routes instead of eager imports
- Avoid circular dependencies between feature folders

## References

- https://angular.dev/guide/standalone-components
- https://angular.dev/tools/cli
- https://angular.dev/guide/router/lazy-loading
