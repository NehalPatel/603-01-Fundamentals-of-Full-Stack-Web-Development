unit: 1
topic: Brief Recap of Angular 17 core concepts: Components, Services, Routing
objectives: ["Understand the core ideas of Brief Recap of Angular 17 core concepts: Components, Services, Routing","Implement a working example related to Brief Recap of Angular 17 core concepts: Components, Services, Routing","Apply best practices and avoid common mistakes in Brief Recap of Angular 17 core concepts: Components, Services, Routing","Use Angular 17 patterns effectively"]
difficulty: Advanced
---

# Angular 17 Core Concepts: Components, Services, Routing

## Learning Objectives

- Build standalone components and compose templates
- Create injectable services and use `inject` for DI
- Configure routing with `provideRouter` and lazy loading
- Apply built-in template control flow

## Overview

- Components encapsulate view and logic and are standalone by default
- Services provide reusable logic and state via dependency injection
- Router maps URLs to components and supports lazy loading

## Key Concepts

- Standalone `@Component({ standalone: true })`
- Dependency injection with `inject(Service)` in class bodies
- Route config with `Routes` and `loadComponent`
- Template control flow: `@if`, `@for`

## Code Examples

### Component and Service

```ts
import { Component, inject } from '@angular/core';
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class CounterService {
  value = 0;
  inc(){ this.value++; }
}

@Component({
  selector: 'app-counter',
  standalone: true,
  template: `
    <h3>Counter</h3>
    <p>{{ svc.value }}</p>
    <button (click)="svc.inc()">Increment</button>
  `
})
export class CounterComponent {
  svc = inject(CounterService);
}
```

### Routing

```ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter, Routes } from '@angular/router';
import { AppComponent } from './app/app.component';

const routes: Routes = [
  { path: '', loadComponent: () => import('./app/counter.component').then(m => m.CounterComponent) }
];

bootstrapApplication(AppComponent, { providers: [provideRouter(routes)] });
```

### Template Control Flow

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-list',
  standalone: true,
  template: `
    @if(items.length === 0){
      <p>No items</p>
    } @else {
      @for(item of items; track item){
        <p>{{ item }}</p>
      }
    }
  `
})
export class ListComponent {
  items = ['A','B','C'];
}
```

## Practical Exercises

### Exercise

- Create a `UserService` with `getUsers()` returning an array
- Add a `UsersComponent` and route `'/users'` that lists users

### Solution

```ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class UserService {
  getUsers(){ return [{ id: 1, name: 'Ada' }, { id: 2, name: 'Linus' }]; }
}
```

```ts
import { Component, inject } from '@angular/core';
import { UserService } from './user.service';

@Component({
  selector: 'app-users',
  standalone: true,
  template: `
    <h3>Users</h3>
    @for(u of users; track u.id){
      <p>{{ u.name }}</p>
    }
  `
})
export class UsersComponent {
  users = inject(UserService).getUsers();
}
```

```ts
import { Routes } from '@angular/router';

export const routes: Routes = [
  { path: 'users', loadComponent: () => import('./app/users.component').then(m => m.UsersComponent) }
];
```

## Diagram

```mermaid
flowchart LR
  R[Router] --> C[Component]
  C --> S[Service]
```

## Troubleshooting & Pitfalls

- Do not use NgModules for new code; prefer standalone components
- Use `loadComponent` for lazy routes to avoid eager bundle growth
- Avoid tight coupling between services and components; inject abstractions

## References

- https://angular.dev/guide/components
- https://angular.dev/guide/dependency-injection
- https://angular.dev/guide/router
